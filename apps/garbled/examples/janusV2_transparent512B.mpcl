// -*- go -*-

package main

import (
	"crypto/aes"
	"crypto/hmac"
)

// python console, to generate 2kB
// a = "01010101010101010101010101010101" // 16
// b = ""
// >>> for i in range(128): // 16*2=32, 16*4=64, 16*8=128, 16*16=256, 16*32=512, 16*64=1024, 16*128=2048
// ...     b += a
// ...
// >>> print(b)

// 16B: a = "0x01010101010101010101010101010101"
// 32B: a = "0x0101010101010101010101010101010101010101010101010101010101010101"
// 64B: a = "0x01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101"
// 128B: a = "0x0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101"
// 256B: a = "0x01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101"
// 512B: a = "0x0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101"

// sample values for request computation
// Tests to derive CHTS:
// dES: 0x6f2615a108c702c5678f54fc9dbab69716c076189c48250cebeac3576c3611ba
// cShare: 0x677f7ff26ac202469e1a2d39dc001c5e7fcfb1f967a3cb4affa51185facc57ac
// pShare: 0xfbe470a4a1e11bbaa2ebb9da082924f99a20681e5feed0000e2d2b5e613d22df
// pModP: 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
// HS: c571a176894ac7aff65d52522f4d0861060f3c3b96144567dd10fa79d218d878
// label+H2: 0x002012746c7331332063206873207472616666696320825e4f79bbcb0e8adb287cac19c378145b7d6c465734422da6882463eadc905701
// CHTS: 136513e4c51032bb2ba86892f0e3e24a75b4fbfef56d92cc0c57d4c67a847e65
// CATS: 2c1acaa6e88b118bc46287c99d7800ed3d717f9417672afc9dccd2b3656f0e3e

// mH3=clientlabel+H3: 0x002012746c7331332063206170207472616666696320803fe80818374bc995571054979e54a316f266b4908ed43f5df4752bdef093b801
// mIv: 0x000c08746c7331332069760001 (generated with 12)
// mKey: 0x001009746c733133206b65790001 (generated with 16)

// client ECB0: 0xf8895999038a3cb1169a882ebba33ca5
// client ECB1: 0xf0cecf8cdd4452c1f77a297cff13a605
// client key: 93eae267aa1f9088f1735f6435a05add
// client iv: d06ac7f19c2b18e01a62686e
// client masked key: d5ad091155c804d0f135f394a376ed7f
// key mask: 4647eb76ffd794580046acf096d6b7a2
// 256B ECBs: 6a5b4ac24efd0fc5b520d862efe1bd59cd4724e684b2740c032e2f733586cc74cb2eca5b8f4e92660a8929307d30e0859e6ae8a4a62bf0a1080ca0c28416182083a5067033801fce5df37164707be02312db499e4198fa1bd7ef31b1748dbc6f6eb2f01213ddf929af40da7c3ef5e15440abbadccc83dc0e9e207291da6d105b4ce76188d4e4b49e7837bb5e637c661693e635da92bd7633ef064ebc2bec846190ee9428eaf11593a9b226ff43646dee9036fceaccce2b38bf9c8d8b2bca3e0119750323909f7d2c743aceadcfb1f47c9b91a1032bec4e7d68f9b4ca0575b6569e378bec9f85f132322e0691bd272e1ee1925b11ad3b78ef4735880029021a50
// parity: 0x29e0ecc058100b2ee776904b2b265495
// parity mask: 0x4647eb76ffd794580046acf096d6b7a2

// these sample values compute response (server side kdc) data ecbs

// Tests:
// H2: 825e4f79bbcb0e8adb287cac19c378145b7d6c465734422da6882463eadc9057
// H0: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
// H3: 803fe80818374bc995571054979e54a316f266b4908ed43f5df4752bdef093b8
// H7: 2958b125185bf3922e4dfdd580027cc7122bcdc5a9dd5ae82c5e37ac5f729e81
// dHS: 70ee9987162bea6719acab976843acf95514f46d19872c2fabfa1a7bf32c5025
// MS: b02d8f9d19b3ae1ba8d00106dac1ed6b2ea55da3fae83b1f66677fa6a781755f
// SATS: b334fa6ef436aa7767b48ca30dfc567de973ecc692b7da661f486f25754de6c1
// ECB1: 895b8c63da8da17e9d6d30c62f09d6f5 // ecb1
// ECBK: 9b89f7120fe41972a4e81f2e63453807 // ecb0
// serverIv: cac3cc248a5e1db3ebbd2a8a
// serverKey: 2ca886649783b6cd626a4b04a96be1ef
// masked server key: d5ad091155c804d0f135f394a376ed7f (mask: 4647eb76ffd794580046acf096d6b7a2)

// used to check/match ecb32, ecb33
// chipertext chunks: ce64df1813d37137142dc0579dc7f4e2ba4f8c7e1fe62b23747998b59da16a3f
// chunkIndex: 32
// number chunks: 2
// plaintext chunks: 302c353631204575726f227d2c227072696365223a2233383030322e32222c22

// dES: 0x6f2615a108c702c5678f54fc9dbab69716c076189c48250cebeac3576c3611ba
// cShare: 0x677f7ff26ac202469e1a2d39dc001c5e7fcfb1f967a3cb4affa51185facc57ac
// pShare: 0xfbe470a4a1e11bbaa2ebb9da082924f99a20681e5feed0000e2d2b5e613d22df
// pModP: 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
// HS: c571a176894ac7aff65d52522f4d0861060f3c3b96144567dd10fa79d218d878
// label+H2: 0x002012746c7331332063206873207472616666696320825e4f79bbcb0e8adb287cac19c378145b7d6c465734422da6882463eadc905701
// mH0=label+H0: 0x00200d746c733133206465726976656420e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b85501
// mH3=serverlabel+H3: 0x002012746c7331332073206170207472616666696320803fe80818374bc995571054979e54a316f266b4908ed43f5df4752bdef093b801
// server mIv: 0x000c08746c7331332069760001 (generated with 12)
// server mKey: 0x001009746c733133206b65790001 (generated with 16)

// Tests to derive SHTS:
// dES: 0x6f2615a108c702c5678f54fc9dbab69716c076189c48250cebeac3576c3611ba
// cShare: 0x677f7ff26ac202469e1a2d39dc001c5e7fcfb1f967a3cb4affa51185facc57ac
// pShare: 0xfbe470a4a1e11bbaa2ebb9da082924f99a20681e5feed0000e2d2b5e613d22df
// pModP: 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
// HS: c571a176894ac7aff65d52522f4d0861060f3c3b96144567dd10fa79d218d878
// hTwo=mH2=label+H2: 0x002012746c7331332073206873207472616666696320825e4f79bbcb0e8adb287cac19c378145b7d6c465734422da6882463eadc905701
// SHTS: 0x7691bca4c1a92ffc70efe68a178d928540f47254512c290693fbc2a8c28ab59c
// server Parity 16kB: 0x03c5c032c848a055816d588ea53d15c1
// parity mask: "0x4647eb76ffd794580046acf096d6b7a2"

// secret mask (16 bytes): 0x4647eb76ffd794580046acf096d6b7a2

// MPCLDIR=./../../ ./garbled -v -i 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff,0xfbe470a4a1e11bbaa2ebb9da082924f99a20681e5feed0000e2d2b5e613d22df,0x6f2615a108c702c5678f54fc9dbab69716c076189c48250cebeac3576c3611ba,0x0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101 examples/janusV2_transparent512B.mpcl
type Garbler struct {
	modP           uint512
	privShare      uint512
	dES            [32]byte
	plainChunkResp [512]byte
}

// MPCLDIR=./../../ ./garbled -e -v -i 0x677f7ff26ac202469e1a2d39dc001c5e7fcfb1f967a3cb4affa51185facc57ac,0x002012746c7331332073206873207472616666696320825e4f79bbcb0e8adb287cac19c378145b7d6c465734422da6882463eadc905701,0x00200d746c733133206465726976656420e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b85501,0x002012746c7331332073206170207472616666696320803fe80818374bc995571054979e54a316f266b4908ed43f5df4752bdef093b801,0x000c08746c7331332069760001,0x001009746c733133206b65790001 examples/janusV2_transparent512B.mpcl
type Evaluator struct {
	privShare uint512
	hTwo      [55]byte
	hZero     [50]byte
	hThree    [55]byte
	ivLabel   [13]byte
	keyLabel  [14]byte
}

func main(g Garbler, e Evaluator) ([]byte, []byte, []byte, []byte) { // uint8, ([]byte, []byte), []byte

	// combine secret shares into DHE
	DHE := (g.privShare + e.privShare) % g.modP
	bytesDHE := uint512ToByte(DHE)[32:]
	// compute HS
	HS := hmac.SumSHA256(bytesDHE[:], g.dES)

	// compute SHTS
	var mH2 [55]byte
	// must be set individually because 0x00 start is discarded when parsed
	mH2[0] = 0x00
	for i := 1; i < 55; i++ {
		mH2[i] = e.hTwo[i-1]
	}
	SHTS := hmac.SumSHA256(mH2[:], HS)

	// compute dHS
	var mH0 [50]byte
	mH0[0] = 0x00
	for i := 1; i < 50; i++ {
		mH0[i] = e.hZero[i-1]
	}
	dHS := hmac.SumSHA256(mH0[:], HS)

	// compute MS
	var zeros32 [32]byte
	MS := hmac.SumSHA256(zeros32[:], dHS)

	// compute iv (to be disclosed in plain)
	var mIv [13]byte
	mIv[0] = 0x00
	for i := 1; i < 13; i++ {
		mIv[i] = e.ivLabel[i-1]
	}

	// compute client traffic key
	var mKey [14]byte
	mKey[0] = 0x00
	for i := 1; i < 14; i++ {
		mKey[i] = e.keyLabel[i-1]
	}

	// compute SATS
	var mH3 [55]byte
	mH3[0] = 0x00
	for i := 1; i < 55; i++ {
		mH3[i] = e.hThree[i-1]
	}
	SATS := hmac.SumSHA256(mH3[:], MS)

	// compute iv (to be disclosed in plain)
	iv := hmac.SumSHA256(mIv[:], SATS)[:12]

	// compute server traffic key
	key := hmac.SumSHA256(mKey[:], SATS)[:16]

	// compute response ecbs
	var zeros16 [16]byte
	ECBK := aes.Block128(key, zeros16)
	nonce := getNonce(iv, 1)
	ECB1 := aes.Block128(key, nonce)
	var counter [aes.BlockSize]byte
	counter = memcpy(counter, 0, iv, 0)
	counter = incr(counter)

	// server side response ecb verification
	var block [aes.BlockSize]byte
	numberChunks := (16 * 32)
	var ecbs [numberChunks]byte

	// loop increments with 16 step size
	for i := 0; i < numberChunks; i += aes.BlockSize {
		counter = incr(counter)
		block = aes.Block128(key, counter)
		for j := 0; j < aes.BlockSize; j++ {
			ecbs[i+j] = block[j]
		}
	}

	return SHTS[:], ECBK[:], ECB1[:], ecbs[:]
}

func byteToUint128(x [16]byte) uint128 {
	var r uint128

	for i := 0; i < len(x); i++ {
		r <<= 8
		r |= uint128(x[i])
	}
	return r
}

func uint128ToByte(x uint128) [16]byte {
	var r [16]byte

	for i := 0; i < 16; i++ {
		r[15-i] = x & 0xff
		x >>= 8
	}
	return r
}

func incr(counter [aes.BlockSize]byte) [aes.BlockSize]byte {
	var c uint32

	for i := 0; i < 4; i++ {
		c <<= 8
		c |= uint32(counter[12+i])
	}
	c++
	for i := 0; i < 4; i++ {
		counter[15-i] = c & 0xff
		c >>= 8
	}
	return counter
}

func memcpy(dst []byte, dstOfs int, src []byte, srcOfs int) []byte {
	for i := 0; srcOfs+i < len(src) && dstOfs+i < len(dst); i++ {
		dst[dstOfs+i] = src[srcOfs+i]
	}
	return dst
}

func byteToUint512(x [64]byte) uint512 {
	var r uint512

	for i := 0; i < len(x); i++ {
		r <<= 8
		r |= uint512(x[i])
	}
	return r
}

func uint512ToByte(x uint512) [64]byte {
	var r [64]byte

	for i := 0; i < 64; i++ {
		r[63-i] = x & 0xff
		x >>= 8
	}
	return r
}

func getNonce(iv [12]byte, counter uint32) [16]byte {
	var nonce [16]byte
	for i := 0; i < 12; i++ {
		nonce[i] = iv[i]
	}
	// var counter uint32
	// counter = 1
	counterBytes := uint32ToByte(counter)
	for i := 0; i < 4; i++ {
		nonce[12+i] = counterBytes[i]
	}
	return nonce
}

func uint32ToByte(x uint32) [4]byte {
	var r [4]byte

	for i := 0; i < 4; i++ {
		r[3-i] = x & 0xff
		x >>= 8
	}
	return r
}
